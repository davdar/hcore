module FP.Data.SMatrix.Storable where

-- import Prelude ()
-- import Foreign.Storable
-- import FP.Classes.Monad
-- import qualified FP.Data.SStream as SS
-- import qualified FP.Data.Stream as S
-- import FP.PrePrelude
-- import FP.Data.SInt
-- import FP.Classes.SSequence2D
-- import FP.Classes.Sequence2D
-- import FP.Data.Nat
-- import FP.Classes.Static
-- import FP.Data.SVector
-- import FP.Classes.Functor
-- import FP.Data.Matrix.Storable
-- import FP.Classes.Compat
-- 
-- data SMatrixStorable (i::Nat) (j::Nat) a = SMatrixStorable
--   { smatrixStorableRows :: {-# UNPACK #-} !(SInt i)
--   , smatrixStorableCols :: {-# UNPACK #-} !(SInt j)
--   , smatrixStorableData :: {-# UNPACK #-} !(SVectorStorable (i*j) a)
--   }
-- 
-- type instance Compat (SMatrixStorable i j) = Storable
-- 
-- instance Static2 SMatrixStorable where
--   type Stripped2 SMatrixStorable = MatrixStorable
--   stripS2 (SMatrixStorable r c d) = MatrixStorable (stripS r) (stripS c) $ stripS1 d
--   unsafeS2 (MatrixStorable r c d) = SMatrixStorable (unsafeS r) (unsafeS c) $ unsafeS1 d
-- 
-- instance CFunctor (SMatrixStorable i j) where
--   cmapM f (SMatrixStorable r c d) = liftM (SMatrixStorable r c) $ cmapM f d
-- 
-- instance SSequence2D SMatrixStorable where
--   toRowStreamsS = SS.unsafe . S.map SS.unsafe . toRowStreams . stripS2
--   toColStreamsS = SS.unsafe . S.map SS.unsafe . toColStreams . stripS2
--   fromRowStreamsS iS jS ss = unsafeS2 $ fromRowStreams (stripS iS) (stripS jS) $ S.map SS.strip $ SS.strip ss
--   fromColStreamsS iS jS ss = unsafeS2 $ fromColStreams (stripS iS) (stripS jS) $ S.map SS.strip $ SS.strip ss
--   rowsS = smatrixStorableRows
--   colsS = smatrixStorableCols
--   (|!!|) m (iS, jS) = stripS2 m !! (stripS iS, stripS jS)
-- 
-- -- instance (Storable a) => IdxIterable (M i j a) where
-- --   type Index (M i j a) = (BInt i, BInt j)
-- --   iiterOnL = _iiterOnL
-- --   iiterOnR = _iiterOnR
-- --   (!) = _index
-- -- instance CFunctor (M i j) where
-- --   type Compat (M i j) = Storable
-- --   cmap = cmapFromIcmap
-- -- instance IdxCFunctor (M i j) where
-- --   type FIndex (M i j) = (BInt i, BInt j)
-- --   icmap = icmapFromIcmapM
-- -- instance CTraversable (M i j) where
-- --   cmapM = cmapMFromIcmapM
-- -- instance IdxCTraversable (M i j) where
-- --   icmapM = _icmapM
-- -- instance (Storable a, Pretty a) => Pretty (M i j a) where
-- --   pretty = _pretty pretty
-- -- instance (Storable a, Show a) => Show (M i j a) where
-- --   show = showPretty . _pretty prettyFromShow
-- -- 
-- -- toHM :: (Element a) => M i j a -> Matrix a
-- -- toHM m = HM.reshape (stripI $ cols m) $ V.stripIV (unrollM m)
-- -- 
-- -- fromHM :: (Element a) => Matrix a -> (forall i j. M i j a -> b) -> b
-- -- fromHM m k = k $ rollM (unsafeI $ HM.rows m) (unsafeI $ HM.cols m) $ V.unsafeIV $ HM.flatten m
-- -- 
-- -- unsafeFromHM :: forall i j a. (Element a) => Matrix a -> M i j a
-- -- unsafeFromHM m = fromHM m (unsafeCoerce :: forall i i' j j'. M i j a -> M i' j' a)
-- -- 
-- -- trans :: (Element a) => M i j a -> M j i a
-- -- trans = unsafeFromHM . HM.trans . toHM
-- -- 
-- -- inv :: M i j Double -> M i j Double
-- -- inv = unsafeFromHM . HM.inv . toHM
-- -- 
-- -- choleskyM :: M i j Double -> Maybe (M i j Double)
-- -- choleskyM = liftM unsafeFromHM . HM.mbCholSH . toHM
-- -- 
-- -- cholesky :: M i j Double -> M i j Double
-- -- cholesky m = case choleskyM m of
-- --   Nothing -> error "cholesky on non-positive-definite matrix"
-- --   Just x -> x
-- -- 
-- -- det :: M i i Double -> Double
-- -- det = HM.det . toHM
